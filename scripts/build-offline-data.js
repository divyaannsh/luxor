/**
 * Script to build complete offline data structure from fetched data
 * This combines all data and maps image URLs to local paths
 * 
 * Usage: node scripts/build-offline-data.js
 */

const fs = require('fs').promises;
const path = require('path');

const DATA_DIR = path.join(__dirname, '../data');
const OUTPUT_FILE = path.join(__dirname, '../Actions/offlineData.js');

// Read JSON file
async function readJSON(filename) {
  try {
    const filepath = path.join(DATA_DIR, filename);
    const content = await fs.readFile(filepath, 'utf8');
    return JSON.parse(content);
  } catch (error) {
    console.warn(`‚ö†Ô∏è  Could not read ${filename}: ${error.message}`);
    return null;
  }
}

// Replace image URLs with local paths
function replaceImageUrls(data, imageMapping) {
  if (!data || !imageMapping) return data;

  function traverse(obj) {
    if (!obj || typeof obj !== 'object') return;

    for (const key in obj) {
      const value = obj[key];

      if (typeof value === 'string') {
        // Check if it's an image URL
        if (
          value.match(/\.(jpg|jpeg|png|gif|webp|svg|pdf)$/i) ||
          value.includes('root_folder_name') ||
          value.includes('file_name') ||
          key.includes('image') ||
          key.includes('icon') ||
          key.includes('file')
        ) {
          // Try to find mapping
          for (const [url, localPath] of Object.entries(imageMapping)) {
            if (value.includes(url) || url.includes(value)) {
              obj[key] = localPath;
              break;
            }
          }

          // If it's a path like root_folder_name + file_name, construct local path
          if (obj.root_folder_name && obj.file_name) {
            const fullPath = `${obj.root_folder_name}${obj.file_name}`;
            for (const [url, localPath] of Object.entries(imageMapping)) {
              if (url.includes(fullPath) || fullPath.includes(url)) {
                obj[key] = localPath;
                break;
              }
            }
          }
        }
      } else if (Array.isArray(value)) {
        value.forEach(item => traverse(item));
      } else if (typeof value === 'object') {
        traverse(value);
      }
    }
  }

  const cloned = JSON.parse(JSON.stringify(data));
  traverse(cloned);
  return cloned;
}

// Build complete offline data structure
async function buildOfflineData() {
  console.log('üî® Building offline data structure...\n');

  try {
    // Read all data files
    const allData = await readJSON('all-data.json');
    const imageMapping = await readJSON('image-mapping.json');

    if (!allData) {
      console.error('‚ùå Could not read all-data.json. Run fetch-offline-data.js first.');
      process.exit(1);
    }

    // Replace image URLs with local paths
    const offlineData = replaceImageUrls(allData, imageMapping);

    // Generate JavaScript file
    const jsContent = `/**
 * Complete offline data for Luxor website
 * This file is auto-generated by build-offline-data.js
 * DO NOT EDIT MANUALLY
 * 
 * Generated: ${new Date().toISOString()}
 * 
 * @webpackIgnore
 * @next/head disable
 */

// Disable HMR for this large file to prevent Fast Refresh issues
// eslint-disable-next-line @next/next/no-assign-module-variable
if (typeof module !== 'undefined' && module.hot) {
  module.hot.decline();
}

export const offlineData = ${JSON.stringify(offlineData, null, 2)};

// Helper functions for accessing data
export const getCategories = () => offlineData.categories || [];
export const getGlobalProducts = () => offlineData.globalProducts || {};
export const getPens = () => offlineData.pens || [];
export const getPenCategories = () => offlineData.penCategories || [];
export const getMarkerCategories = () => offlineData.markerCategories || [];
export const getMasterProducts = () => offlineData.masterProducts || [];
export const getCategoryProducts = (categoryId) => offlineData.categoryProducts?.[categoryId] || {};

// Get product by ID
export const getProductById = (id) => {
  const allProducts = [
    ...(offlineData.globalProducts?.cat_wise_products || []),
    ...(offlineData.pens || []),
    ...(offlineData.masterProducts || [])
  ];
  return allProducts.find(p => p._id === id || p._id?.toString() === id);
};

// Get products by category
export const getProductsByCategory = (categoryId, catType) => {
  if (offlineData.categoryProducts?.[categoryId]) {
    return offlineData.categoryProducts[categoryId];
  }
  
  // Fallback: filter from all products
  const allProducts = [
    ...(offlineData.globalProducts?.cat_wise_products || []),
    ...(offlineData.pens || [])
  ];
  
  return {
    cat_wise_products: allProducts.filter(p => 
      p.category_type === categoryId || 
      p.main_category_type === categoryId ||
      p.cat_type === catType
    ),
    total: allProducts.length
  };
};

export default offlineData;
`;

    // Write to file
    await fs.writeFile(OUTPUT_FILE, jsContent);
    console.log(`‚úì Offline data built: ${OUTPUT_FILE}`);

    // Statistics
    console.log('\nüìä Data Summary:');
    console.log(`   - Categories: ${offlineData.categories?.length || 0}`);
    console.log(`   - Global Products: ${offlineData.globalProducts?.cat_wise_products?.length || 0}`);
    console.log(`   - Pens: ${offlineData.pens?.length || 0}`);
    console.log(`   - Pen Categories: ${offlineData.penCategories?.length || 0}`);
    console.log(`   - Marker Categories: ${offlineData.markerCategories?.length || 0}`);
    console.log(`   - Master Products: ${offlineData.masterProducts?.length || 0}`);
    console.log(`   - Category Products: ${Object.keys(offlineData.categoryProducts || {}).length} categories`);

    console.log('\n‚úÖ Offline data build complete!');
    console.log('\nüí° Next steps:');
    console.log('   1. Update Actions/action.js to use offline data');
    console.log('   2. Update service worker to cache all assets');
    console.log('   3. Test offline functionality');

  } catch (error) {
    console.error('‚ùå Error building offline data:', error);
    process.exit(1);
  }
}

// Run the script
if (require.main === module) {
  buildOfflineData();
}

module.exports = { buildOfflineData };
